<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>example.html</title>
        <style type="text/css">
          .end-element { fill : #FFCCFF; }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.17.1/flowchart.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.1/js/bootstrap.bundle.min.js"></script>
        <!-- <script src="../release/flowchart.min.js"></script> -->
        <script>

            window.onload = function () {
                var btn = document.getElementById("run"),
                    cd = document.getElementById("code"),
                    chart;
                    
                (btn.onclick = function () {
                    var code = cd.value;

                    if (chart) {
                      chart.clean();
                    }

                    chart = flowchart.parse(code);
                    chart.drawSVG('canvas', {
                      'x': 0,
                      'y': 0,
                      'line-width': 3,
                      //'maxWidth': 15,//ensures the flowcharts fits within a certain width
                      'line-length': 50,
                      'text-margin': 10,
                      'font-size': 14,
                      'font': 'normal',
                      'font-family': 'Helvetica',
                      'font-weight': 'normal',
                      'font-color': 'black',
                      'line-color': 'black',
                      'element-color': 'black',
                      'fill': 'white',
                      'yes-text': 'yes',
                      'no-text': 'no',
                      'arrow-end': 'block',
                      'scale': 1,
                      'symbols': {
                        'start': {
                          'font-size': 14,
                          'font-color': 'yellow',
                          'element-color': 'blue',
                          'fill': 'green',
                          'class': 'start-element'
                        },
                        'inputoutput': {
                          'font-color': 'black',
                          'element-color': 'black',
                          'fill': 'bisque'
                        },
                        'operation': {
                          'font-color': 'black',
                          'element-color': 'black',
                          'fill': 'linen'
                        },
                        'subroutine': {
                          'font-color': 'black',
                          'element-color': 'blue',
                          'fill': 'lightgreen'
                        },
                        'condition': {
                          'font-color': 'red',
                          'element-color': 'black',
                          'fill': 'yellow'
                        },
                        'end':{
                          'font-size': 20,
                          'class': 'end-element'
                        }
                      },
                      'flowstate' : {
                        //'past' : { 'fill' : '#CCCCCC', 'font-size' : 12},
                        //'current' : {'fill' : 'yellow', 'font-color' : 'red', 'font-weight' : 'bold'},
                        //'future' : { 'fill' : '#FFFF99'},
                        'request' : { 'fill' : 'blue'},
                        'invalid': {'fill' : '#444444'},
                        'approved' : { 'fill' : '#58C4A3', 'font-size' : 12, 'yes-text' : 'APPROVED', 'no-text' : 'n/a' },
                        'rejected' : { 'fill' : '#C45879', 'font-size' : 12, 'yes-text' : 'n/a', 'no-text' : 'REJECTED' }
                      }
                    });
                    //create base64 encoding of SVG to generate download link for title(without html or htm).SVG
                    var currentCanvasDIV = document.getElementById('canvas')
                    var currentDrawSVG = currentCanvasDIV.innerHTML.replaceAll('ë','e');

                    const OUTsvgBASE64 = btoa(currentDrawSVG)
                    doctitle = document.title.replace('.html','');
                    doctitle = doctitle.replace('.htm','');


                    var currentCanvasDIV = document.getElementById('canvas')
                    var currentDrawSVG = currentCanvasDIV.innerHTML.replaceAll('ë','e');
                    svgSource = currentDrawSVG
                    svgXML = currentDrawSVG;
                    // Use SVG Height and Width from the SVG XML to set canvas size
                    svgXMLsubstringHeight = svgXML.substring(svgXML.indexOf('height='), svgXML.indexOf('version='));
                    svgXMLsubstringWidth = svgXML.substring(svgXML.indexOf('width='), svgXML.indexOf('xmlns='));
                    HeightValue = svgXMLsubstringHeight.substring(svgXMLsubstringHeight.indexOf('"')+1,svgXMLsubstringHeight.lastIndexOf('"'));
                    WidthValue = svgXMLsubstringWidth.substring(svgXMLsubstringWidth.indexOf('"')+1,svgXMLsubstringWidth.lastIndexOf('"'));
                    HeightValueInt = Math.round(HeightValue)
                    WidthValueInt = Math.round(WidthValue)
                    // setup input for base64SvgToBase64Png
                    let svgSrc = "data:image/svg+xml;base64,"+OUTsvgBASE64;
                    var pngBase
                    imageUtil.base64SvgToBase64Png(svgSrc, WidthValueInt, HeightValueInt).then(pngSrc => {
                    pngBase = pngSrc
                    // output download link for base64 PNG converted on download from base64
                    var pngOutHtml = `<a href="${pngBase}" download="${doctitle}.png">PNG - Click here to download current rendered flowchart as ${doctitle}.png</a>`
                    document.getElementById("pngbase64").innerHTML=pngOutHtml;
                    });    
                    // output download link for base64 SVG converted on download from base64
                    var svgOutHtml = `<a href="data:image/svg+xml;base64,${OUTsvgBASE64}" download=${doctitle}.svg>SVG - Click here to download current rendered flowchart as ${doctitle}.svg</a> `
                        document.getElementById("svgbase64").innerHTML=svgOutHtml;
                    })();

                            };
                 

// derived from https://stackoverflow.com/a/64800570
// we need to use web browser canvas to generate a image. In this case png
let imageUtil = {};
/**
 * converts a base64 encoded data url SVG image to a PNG image
 * @param originalBase64 data url of svg image
 * @param width target width in pixel of PNG image
 * @param secondTry used internally to prevent endless recursion
 * @return {Promise<unknown>} resolves to png data url of the image
 */
imageUtil.base64SvgToBase64Png = function (originalBase64, width, height, secondTry) {
    return new Promise(resolve => {
        let img = document.createElement('img');
        img.onload = function () {
            if (!secondTry && (img.naturalWidth === 0 || img.naturalHeight === 0)) {
                let svgDoc = base64ToSvgDocument(originalBase64);
                let fixedDoc = fixSvgDocumentFF(svgDoc);
                return imageUtil.base64SvgToBase64Png(svgDocumentToBase64(fixedDoc), width, height, true).then(result => {
                    resolve(result);
                });
            }
            //document.body.appendChild(img);
            let canvas2 = document.createElement("canvas");
            //document.body.removeChild(img);
            canvas2.width = width;
            canvas2.height = height;
            let ctx = canvas2.getContext("2d");
            ctx.drawImage(img, 0, 0, canvas2.width, canvas2.height);
            try {
                let data = canvas2.toDataURL('image/png');
                resolve(data);
            } catch (e) {
                resolve(null);
            }
        };
        img.src = originalBase64;
    });
}

//needed because Firefox doesn't correctly handle SVG with size = 0, see https://bugzilla.mozilla.org/show_bug.cgi?id=700533
function fixSvgDocumentFF(svgDocument) {
    try {
        let widthInt = parseInt(svgDocument.documentElement.width.baseVal.value) || 500;
        let heightInt = parseInt(svgDocument.documentElement.height.baseVal.value) || 500;
        svgDocument.documentElement.width.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, widthInt);
        svgDocument.documentElement.height.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, heightInt);
        return svgDocument;
    } catch (e) {
        return svgDocument;
    }
}

function svgDocumentToBase64(svgDocument) {
    try {
        let base64EncodedSVG = btoa(new XMLSerializer().serializeToString(svgDocument));
        return 'data:image/svg+xml;base64,' + base64EncodedSVG;
    } catch (e) {
        return null;
    }
}

function base64ToSvgDocument(base64) {
    let svg = atob(base64.substring(base64.indexOf('base64,') + 7));
    svg = svg.substring(svg.indexOf('<svg'));
    let parser = new DOMParser();
    return parser.parseFromString(svg, "image/svg+xml");
} 
        </script>

        <script>
            function HelpText() {
              var x = document.getElementById("HelpTextBlock");
              if (x.style.display === "none") {
                x.style.display = "block";
              } else {
                x.style.display = "none";
              }
            }
        </script>
    </head>
    <body>
        <div><textarea id="code" style="width: 100%;" rows="11">op2=>operation: import pandas as pd
op4=>operation: from os import listdir
op6=>operation: import os
op8=>operation: from os.path import isfile, join
op10=>operation: import matplotlib.pyplot as plt
op12=>operation: from matplotlib.widgets import CheckButtons
op14=>operation: import numpy as np
op16=>operation: import math
op18=>operation: import time
op20=>operation: from numba import jit
op22=>operation: from tqdm import tqdm
op24=>operation: from scipy import optimize
op26=>operation: import yaml
op28=>operation: import scipy.signal as signal
op30=>operation: from astropy.timeseries import LombScargle
op32=>operation: from scipy.interpolate import UnivariateSpline
op34=>operation: import ast
op36=>operation: import seaborn as sns
op38=>operation: from matplotlib.colors import LogNorm, Normalize
op40=>operation: from rich import print
op42=>operation: from rich.traceback import install
op44=>operation: from rich.console import Console
sub46=>subroutine: install()
op48=>operation: console = Console()
op50=>operation: with open('find_variable.yml') as f:
    config = yaml.safe_load(f)
op52=>operation: F_threshold = config['Thresholds']['F_threshold']
op54=>operation: R_threshold = config['Thresholds']['R_threshold']
op56=>operation: amplitude_threshold = config['Thresholds']['amplitude_threshold']
op58=>operation: amp_diff_threshold = config['Thresholds']['amp_diff_threshold']
op60=>operation: T_threshold = config['Thresholds']['T_threshold']
op62=>operation: F_and_R_threshold = config['Thresholds']['F_and_R_threshold']
op64=>operation: show_galaxies = config['Plots']['TargetGalaxies']
op66=>operation: value = config['Value']
op68=>operation: path = config['Paths']['path']
op70=>operation: load_path = config['Paths']['load_path']
op72=>operation: activity_path = config['Paths']['activity_path']
op74=>operation: groups = pd.DataFrame({'function': ['periodic', 'linear', 'supernova', 'F_var_R', 'minPoints'], 'count': [0, 0, 0, 0, 0]})
op76=>operation: class Conditions():

    def format_return_values(results):
        print(results)
        if ((type(results) == type(True)) or (len(results) > 2)):
            return results
        formatted_results = []
        for (boolean, value) in results:
            if isinstance(value, float):
                formatted_value = f'{value:.3e}'
            else:
                formatted_value = value
            formatted_results.append((boolean, formatted_value))
        return formatted_results

    def __init__(self, R=0, F=0, amp_diff=0, T=0, Dt=500000000.0, std=0, up=0, down=0, mean=0, peakA=0, peakC=0, lange=0, periodicpercent=0, StartEndDiff=0, redshift=(- 1), periodicFast=0, magnitude=0, periodicFastFreq=0, amplitude=0, classify=False):
        self.R = R
        self.F = F
        self.amp_diff = amp_diff
        self.T = T
        self.Dt = Dt
        self.std = std
        self.up = up
        self.down = down
        self.mean = mean
        self.peakA = peakA
        self.peakC = peakC
        self.lange = lange
        self.periodicpercent = periodicpercent
        self.StartEndDiff = StartEndDiff
        self.classify = classify
        self.redshift = redshift
        self.periodicFast = periodicFast
        self.magnitude = magnitude
        self.periodicFastFreq = periodicFastFreq
        self.amplitude = amplitude

    def main(self, *, R=0, F=0, amp_diff=0, T=0, Dt=500000000.0, std=0, up=0, down=0, mean=0, peakA=0, peakC=0, lange=0, periodicpercent=0, StartEndDiff=0, redshift=(- 1), periodicFast=0, magnitude=0, periodicFastFreq=0, amplitude=0, classify=False):
        self.R = R
        self.F = F
        self.amp_diff = amp_diff
        self.T = T
        self.Dt = Dt
        self.std = std
        self.up = up
        self.down = down
        self.mean = mean
        self.peakA = peakA
        self.peakC = peakC
        self.lange = lange
        self.periodicpercent = periodicpercent
        self.StartEndDiff = StartEndDiff
        self.classify = classify
        self.redshift = redshift
        self.periodicFast = periodicFast
        self.magnitude = magnitude
        self.periodicFastFreq = periodicFastFreq
        self.amplitude = amplitude
        if (classify == False):
            return (Conditions.periodicFast(self) and Conditions.minPoints(self) and (not Conditions.supernova(self)))
        elif classify:
            return (Conditions.periodic(self), Conditions.linear(self), Conditions.supernova(self), Conditions.F_var_R(self), Conditions.periodicFast(self), Conditions.minPoints(self))

    def F_var_R(self):
        bedingung = ((self.R > R_threshold) and (F_threshold < self.F))
        return (bedingung, (self.R + self.F))

    def periodic(self):
        cond = (((self.amp_diff > amp_diff_threshold) and (self.T > T_threshold[0]) and (((self.T / ((60 * 60) * 24)) * 365) < (self.Dt * 2))) and (self.T > 100000000.0))
        cond = (self.amplitude >= 0.15)
        if (self.classify == False):
            return cond
        else:
            return (cond, (self.periodicpercent * 100))

    def periodic2(self):
        return ((self.amp_diff > (amp_diff_threshold / 2)) and (((self.T / ((60 * 60) * 24)) * 365) < (365 * 10)) and (((self.T / ((60 * 60) * 24)) * 365) > 50))

    def linear(self):
        return (((((1 / self.T) / ((60 * 60) * 24)) * 365) > (self.Dt * 2)) and (self.amplitude > 0.5))

    def supernova(self):
        peak = False
        width = False
        height = False
        std1 = False
        if ((self.peakA > 0.25) and (self.peakA <= 3)):
            peak = True
        if ((self.peakC > 400000) and (self.peakC <= 10000000)):
            width = True
        if (self.mean < 0.5):
            height = True
        if (self.std < 0.12):
            std1 = True
        return (peak and width and height and std1)

    def changeActivity(self):
        linear = ((((self.T / ((60 * 60) * 24)) * 365) > (self.Dt * 2)) and (self.amp_diff > (amp_diff_threshold * 4)))
        periodic = (((self.amp_diff > amp_diff_threshold) and (self.T > T_threshold[0]) and (((self.T / ((60 * 60) * 24)) * 365) < (self.Dt * 2))) and (((self.T / ((60 * 60) * 24)) * 365) > (self.Dt / 4)))
        return (abs(self.StartEndDiff) > 0.25)

    def periodicFast(self):
        return (self.periodicFast >= 0.1)

    def minPoints(self):
        return (self.lange > 250)

    def printAllParameters(self):
        string = f'R: {self.R}, F: {self.F}, amp_diff: {self.amp_diff}, T: {self.T}, Dt: {self.Dt}, std: {self.std}, up: {self.up}, down: {self.down}, mean: {self.mean}, peakA: {self.peakA}, peakC: {self.peakC}, lange: {self.lange}, periodicpercent: {self.periodicpercent}, StartEndDiff: {self.StartEndDiff}, classify: {self.classify}, redshift: {self.redshift}, periodicFast: {self.periodicFast}, magnitude: {self.magnitude}, periodicFastFreq: {self.periodicFastFreq}, amplitude: {self.amplitude}'
        return string
op78=>operation: CONDITION = Conditions().main
op80=>operation: class Plots():

    @staticmethod
    def plotMateches(df, df_names):
        (fig, ax) = plt.subplots(figsize=(10, 8))
        sns.heatmap(df, annot=True, cmap='Blues', linewidths=0.5, linecolor='black', cbar_kws={'label': 'Correlation'})
        plt.title('Heatmap of Values', fontsize=18)
        plt.xlabel('berechnet', fontsize=14)
        plt.ylabel('manuell', fontsize=14)
        plt.xticks(rotation=45, ha='right', fontsize=12)
        plt.yticks(rotation=0, fontsize=12)

        def on_click(event):
            if (event.inaxes == ax):
                (x, y) = (int(event.xdata), int(event.ydata))
                if ((0 <= x < len(normalized_df.columns)) and (0 <= y < len(normalized_df.index))):
                    x_label = normalized_df.columns[x]
                    y_label = normalized_df.index[y]
                    SN = df_names[x_label][y_label]
                    plot = SN
                    print(f'''

======== PLOTS len:{len(plot)}========
n''')
                    print(f'''
x = {x_label} ===== y = {y_label}
''')
                    for val in plot:
                        (fig_new, ax_new) = plt.subplots()
                        params = FindActive.load_parameters(val)
                        print(f'''=== {val} ===
{Conditions(**params).printAllParameters()}''')
                        Plots.plot_curves(val, True)
                        plt.show(block=False)
                        plt.pause(0.1)
                        if (input('nächster Plot: (break for exit) ') == 'break'):
                            print('exit')
                            plt.close()
                            break
                        plt.close()
        fig.canvas.mpl_connect('button_press_event', on_click)
        plt.show()
        plt.close()

    @staticmethod
    def matchesPlot(df):
        df = df.drop(columns=['name'])
        df.set_index('category', inplace=True)
        category_counts = df.groupby('category')['match'].value_counts().unstack(fill_value=0)
        category_counts.drop(columns=['match: False - Notes: Leer, Calc: Leer'], inplace=True)
        category_counts = category_counts.drop(index=False)
        category_counts['corr'] = (category_counts[True] / (category_counts[False] + category_counts[True]))
        heatmap_data = pd.pivot_table(category_counts, values='corr', index='category', columns='category', fill_value=0)
        plt.figure(figsize=(10, 8))
        sns.heatmap(heatmap_data, annot=True, cmap='Blues', linewidths=0.5, linecolor='black', cbar_kws={'label': 'Correlation'})
        plt.title('Heatmap of Values', fontsize=18)
        plt.xlabel('X Name', fontsize=14)
        plt.ylabel('Y Name', fontsize=14)
        plt.xticks(rotation=45, ha='right', fontsize=12)
        plt.yticks(rotation=0, fontsize=12)
        plt.show()
        plt.close()

    def statisticalDistribution(df):
        groups = pd.DataFrame()

        def count_true(columne):
            return sum((1 for value in columne if ((value is True) or (isinstance(value, tuple) and (value[0] == True)))))
        console.print(df.to_string())
        console.print(df.columns.to_list())
        groups = df.apply(count_true, axis=0)
        groups = groups.to_frame().T
        groups.index = ['count']
        groups.loc['count_div_100'] = ((groups.loc['count'] / len(df)) * 100)
        console.print(len(df))
        console.print(groups)

    def periodic_check_with_significance(name):
        curve = FileManager.load_data(name)
        file2 = BasicCalcs.normalize_null(curve)
        file2.dropna(inplace=True)
        numeric_index = BasicCalcs.Datetime_in_Unix(file2.index)
        if (len(numeric_index) < 20):
            return ([], [], 0, 0, 0)
        time_diff = (numeric_index[(- 1)] - numeric_index[0])
        frequency = np.linspace((1 / ((((7 * 24) * 60) * 60) * 365)), (1 / (((10 * 24) * 60) * 60)), 100000)
        ls = LombScargle(numeric_index, file2[value].values)
        power = ls.power(frequency, normalization='standard')
        fap = ls.false_alarm_probability(power.max())
        periods = (1 / frequency)
        valid_indices = (periods > 0)
        periods = periods[valid_indices]
        power = power[valid_indices]
        (fig, (ax_t, ax_p)) = plt.subplots(2, 1, constrained_layout=True)
        ax_t.plot(numeric_index, file2[value].values, 'b+')
        ax_t.set_xlabel('Time [s]')
        ax_t.set_ylabel('Amplitude')
        ax_p.plot(periods, power)
        ax_p.set_xlabel('Period duration [s]')
        ax_p.set_ylabel('Lomb-Scargle Power')
        ax_p.grid(True, which='both', linestyle='--', linewidth=0.5)
        plt.show()
        plt.close()
        console.print(f'False Alarm Probability (FAP): {fap:.5f}')
        if (fap < 0.01):
            console.print('There is a significant periodic signal with >99% confidence!')
        elif (fap < 0.05):
            console.print('There is a periodic signal with >95% confidence.')
        else:
            console.print('No significant periodic signal detected.')

    def periodic_check(name):
        curve = FileManager.load_data(name)
        file2 = BasicCalcs.rolling_mid(curve)
        file2 = BasicCalcs.normalize_null(curve)
        file2.dropna(inplace=True)
        maximum = curve[value].max()
        numeric_index = BasicCalcs.Datetime_in_Unix(file2.index)
        if (len(numeric_index) < 20):
            return ([], [], 0, 0, 0)
        time_diff = (numeric_index[(- 1)] - numeric_index[0])
        w = np.linspace((1 / (((7 * 24) * 60) * 60)), (1 / (time_diff / 4)), 100000)
        pgram = signal.lombscargle(numeric_index, file2[value].values, w, normalize=True)
        periods = ((2 * np.pi) / w)
        periods = (((periods / 60) / 60) / 24)
        numeric_index = (((np.array(numeric_index) / 60) / 60) / 24)
        (fig, (ax_t, ax_w)) = plt.subplots(2, 1, constrained_layout=True)
        ax_t.plot(numeric_index, file2[value].values, 'b+')
        ax_t.set_xlabel('Time [s]')
        ax_w.plot(periods, pgram)
        ax_w.set_xlabel('Period duration [days]')
        ax_w.set_ylabel('Normalized amplitude')
        ax_t.grid(True, which='both', linestyle='--', linewidth=0.5)
        ax_w.grid(True, which='both', linestyle='--', linewidth=0.5)
        plt.show()

    def show_plots(sortname=pd.DataFrame()):
        galaxy_active = pd.read_csv((path + 'new_active_galaxies.csv'))
        files = [f for f in listdir(load_path) if isfile(join(load_path, f))]
        if (len(sortname) > 0):
            name_order = {name: i for (i, name) in enumerate((sortname + '.csv'))}
            sorted_names = sorted(files, key=(lambda x: name_order.get(x, float('inf'))))
            files = sorted_names
        show_galaxies_lower = [item.replace(' ', '').lower() for item in show_galaxies]
        for file in tqdm(files):
            name = file[:(- 4)].replace(' ', '')
            if (len(show_galaxies) > 0):
                if (name.lower() not in show_galaxies_lower):
                    continue
            elif (file[:(- 4)] in galaxy_active['name'].values):
                params = FindActive.load_parameters(file[:(- 4)])
                if ((not CONDITION(**params)) and (not config['Plots']['IgnoreConditions'])):
                    continue
            Plots.plot_curves(file[:(- 4)])

    def standart1(x=None, y=None, z=None, plot=True):
        (name, F_var, R, F_and_R, cuts, amplitude, amp_diff, T, periodicpercent, Dt, std, up, down, mean, peakA, peakC, lange, StartEndDiff, redshift, periodicFast, magnitude) = FindActive.load_parameters(variante=1)
        if (x == None):
            x = 'F_var'
        if (y == None):
            y = 'periodicFast'
        if (z == None):
            (z, z_title) = (cuts, 'cuts')
        else:
            z_title = 'Noch benennen'

        def setup(x):
            return (x, x_title, threshold_x)
        (x, x_title, threshold_x) = setup(x)
        (y, y_title, threshold_y) = setup(y)
        x_target = []
        y_target = []
        x_thresh = []
        y_thresh = []
        if (len(show_galaxies) > 0):
            for i in reversed(range(len(name))):
                if (name[i] in show_galaxies):
                    x_target.append(x[i])
                    y_target.append(y[i])
        aktive_prozent = 0
        variabel = pd.DataFrame(columns=['name', 'F', 'R'])
        for i in range(len(y)):
            if CONDITION(R=R[i], F=F_var[i], amp_diff=amp_diff[i], T=T[i], Dt=Dt[i], std=std[i], up=up[i], down=down[i], mean=mean[i], peakA=peakA[i], peakC=peakC[i], lange=lange[i], periodicpercent=periodicpercent[i]):
                aktive_prozent += 1
                x_thresh.append(x[i])
                y_thresh.append(y[i])
        aktive_prozent = (round(((aktive_prozent / len(y)) * 10000)) / 100)
        corrData = pd.DataFrame(columns=['x', 'y', 'z'])
        corrData['x'] = x
        corrData['y'] = y
        corrData['z'] = z
        if (x_title == 'magnitude'):
            corrData['x'] = abs(corrData['x'])
        if (y_title == 'magnitude'):
            corrData['y'] = abs(corrData['y'])
        if (x_title == 'cuts'):
            corrData = corrData[((corrData['x'] >= 0) & (corrData['y'] >= 0))]
        elif (y_title == 'cuts'):
            corrData = corrData[((corrData['x'] >= 0) & (corrData['y'] >= 0))]
        else:
            corrData = corrData[((corrData['x'] > 0) & (corrData['y'] > 0))]
        corrData['z_x'] = ((corrData['x'] - corrData['x'].mean()) / corrData['x'].std())
        corrData['z_y'] = ((corrData['y'] - corrData['y'].mean()) / corrData['y'].std())
        threshold = 3
        corrData = corrData[((corrData['z_x'].abs() < threshold) & (corrData['z_y'].abs() < threshold))]
        corrData = corrData.drop(columns=['z_x', 'z_y'])
        lenbefore = len(x)
        (x, y, z) = (corrData['x'], corrData['y'], corrData['z'])
        lenafter = len(x)
        geloscht = (lenbefore - lenafter)
        corr = np.corrcoef(x, y)[(0, 1)]
        if plot:
            if (x_title == 'magnitude'):
                x *= (- 1)
            if (y_title == 'magnitude'):
                y *= (- 1)
            print(f'Correlation: {corr} - bereinigt um {geloscht} Datenpunkte')
            if (type(threshold_x) == type(4.2)):
                threshold_x = [threshold_x]
            if (type(threshold_y) == type(4.2)):
                threshold_y = [threshold_y]
            for i in threshold_y:
                continue
                plt.hlines(i, min(x), max(x))
            for i in threshold_x:
                continue
                plt.vlines(i, min(y), max(y))
            plt.scatter(x, y, c=z, s=50, edgecolor='k', alpha=0.5, zorder=1)
            plt.colorbar(label=z_title)
            plt.xlabel(x_title)
            plt.ylabel(y_title)
            if (len(y_target) < 1):
                prozent_korrekte_vorhersagen = (- 1)
            else:
                prozent_korrekte_vorhersagen = (round(((len(np.intersect1d(y_target, y_thresh)) / len(y_target)) * 10000)) / 100)
            if (len(y_thresh) < 1):
                prozent_treffer_in_filter = (- 1)
            else:
                prozent_treffer_in_filter = (round(((len(np.intersect1d(y_thresh, y_target)) / len(y_thresh)) * 10000)) / 100)
            plt.title(f'''Anzahl: {len(x)}, Variabel: {aktive_prozent}%
Filter trifft {prozent_korrekte_vorhersagen}% der Galaxien
Korrekt in Filter: {prozent_treffer_in_filter}%
Correlation: {corr}''')
            plt.grid()
            plt.show()
            plt.close()
        return (corr, geloscht, len(x))

    def plot_curves(name, deactivePlot=False):
        file2 = FileManager.load_data(name)
        file = BasicCalcs.normalize_null(file2)
        (x, y, cam) = (file.index.copy(), file[value].copy(), file['Camera'].copy())
        error1 = file[f'{value} Error'].copy()
        file2 = BasicCalcs.rolling_mid(file, '30D')
        (x1, y1) = (file2.index.copy(), file2[value].copy())
        error2 = file2[f'{value} Error'].copy()
        farben = config['Colors']
        cameras = cam.unique()
        c2 = []
        for i in cam:
            c2.append(farben[np.where((cameras == i))[0][0]])
        c3 = []
        c4 = []
        for (index, i) in enumerate(cam):
            if (file['Filter'].iloc[index] == 'V'):
                c3.append(farben[np.where((cameras == i))[0][0]])
            else:
                c4.append(farben[np.where((cameras == i))[0][0]])
        x_1 = file.loc[((file['Filter'] == 'V'), :)].index.copy()
        x_2 = file.loc[((file['Filter'] == 'g'), :)].index.copy()
        y_1 = file.loc[((file['Filter'] == 'V'), value)].values.copy()
        y_2 = file.loc[((file['Filter'] == 'g'), value)].values.copy()
        error_1 = file.loc[((file['Filter'] == 'V'), f'{value} Error')].values.copy()
        error_2 = file.loc[((file['Filter'] == 'g'), f'{value} Error')].values.copy()
        galaxy_active = pd.read_csv((path + 'new_active_galaxies.csv'))
        params = FindActive.load_parameters(name)
        redshift = galaxy_active.loc[((galaxy_active['name'] == name), 'redshift')].values
        if (redshift > 0.027):
            redshift = 'Neu'
        else:
            redshift = 'Alt'
        (compareString, _, _) = FindActive.compareCategories(name)
        if (name in galaxy_active['name'].values):
            if (not CONDITION(**params)):
                plt.title(f'''NICHT VARIABEL Galaxy: {name} - {redshift}
{compareString}''')
            else:
                plt.title(f'''VARIABEL 
Galaxy: {name} - {redshift}
{compareString}''')
        else:
            plt.title(f'Galaxy: {name} - nicht gefunden')
        plt.plot(x1, y1, zorder=10, label='30 Tage', color='red')
        plt.scatter(x_1, y_1, c=c3, alpha=0.4, zorder=5, marker='x')
        plt.scatter(x_2, y_2, c=c4, alpha=0.4, zorder=5, marker='o')
        plt.grid(color='grey', linestyle='--', linewidth=0.5)
        plt.xlabel('Zeit', fontsize=12)
        plt.ylabel('Fluss (normiert auf 1)', fontsize=12)
        plt.legend(fontsize=10, frameon=True, fancybox=True, framealpha=0.7)
        plt.tight_layout()
        if (deactivePlot == False):
            plt.show()
            plt.close()
op82=>operation: class FileManager():

    def loadRedshift(name1):
        name = name1.lstrip().replace(' ', '').lower()
        galaxy_active = pd.read_csv('pyasassn_tool/mainTargets.csv', delimiter='|')
        galaxy_active['namecheck'] = galaxy_active['name             '].str.lstrip().str.lower().str.replace(' ', '')
        try:
            return galaxy_active.loc[((galaxy_active['namecheck'] == name), 'redshift')].values[0]
        except:
            return (- 1)

    def load_data(file):
        if os.path.exists(((load_path + file) + '.csv')):
            data = pd.read_csv(((load_path + file) + '.csv'), index_col=0)
            data.index = pd.to_datetime(data.index)
            if (len(data[value]) <= 2):
                os.remove(((load_path + file) + '.csv'))
                activity = pd.read_csv(activity_path)
                act = activity.loc[(activity['name'] != file)]
                act.to_csv(activity_path, index=False)
                new_act = pd.read_csv((config['Paths']['path'] + 'new_active_galaxies.csv'))
                new_act = new_act.loc[(new_act['name'] != file)]
                new_act.to_csv((config['Paths']['path'] + 'new_active_galaxies.csv'), index=False)
                console.log(f'Deleted: {file}')
                return (- 1)
            return data
        return pd.DataFrame()

    def load_cuts(name):
        activity = pd.read_csv(activity_path)
        if (name in activity['name'].values):
            cuts = activity.loc[((activity['name'] == name), 'cuts')].values[0]
        else:
            cuts = (- 1)
        return cuts

    def group_galaxies(name):
        file_path = (path + 'new_active_galaxies.csv')
        cuts = FileManager.load_cuts(name)
        try:
            Fvar = FindActive.fractional_variation(name)
            if (Fvar == (- 1)):
                console.print(f'Delete: {name} (hopefully)')
                return
        except:
            console.print(f'Delete: {name} (hopefully)')
            return
        R = FindActive.peak_to_peak_amplitudes(name)
        (_, _, amplitude, amp_diff, period, periodicpercent) = FindActive.periodic(name)
        (_, _, peakA, peakC) = FindActive.peak(name)
        deltaT = BasicCalcs.TimeDifference(name)
        (std, up, down, mean, lange) = FindActive.StdPeak(name)
        StartEndDiff = FindActive.changingActivity(name)
        redshift = FileManager.loadRedshift(name)
        (periodicFast, periodicFastFreq) = FindActive.FourierFastPeriodic(name)
        magnitude = FindActive.absoluteMag(name)
        if (os.path.isfile(file_path) == False):
            with open(file_path, 'w') as datei:
                datei.write('name,activity,R,activity*R,cuts,amplitude,amp_diff,period,periodicpercent,Dt,std,up,down,mean,peakA,peakC,pointCount,StartEndDiff,redshift,periodicFast,periodicFastFreq,magnitude\n')
        with open(file_path, 'a') as datei:
            datei.write(f'''{name},{Fvar},{R},{(Fvar * R)},{cuts},{amplitude},{amp_diff},{period},{periodicpercent},{deltaT.days},{std},{up},{down},{mean},{peakA},{peakC},{lange},{StartEndDiff},{redshift},{periodicFast},{periodicFastFreq},{magnitude}
''')
        return
op84=>operation: class BasicCalcs():

    @staticmethod
    def secondToYears(value):
        return (value / (((365 * 24) * 60) * 60))

    @staticmethod
    def yearsToSeconds(value):
        return (value * (((365 * 24) * 60) * 60))

    def derivation(x, y):
        m = []
        for i in range((len(x) - 1)):
            m.append(((y[(i + 1)] - y[i]) / (x[(i + 1)] - x[i])))
        return (x[:(- 1)], m)

    def format_return_values(results):
        if ((type(results) == type(True)) or (len(results) > 2)):
            return results
        formatted_results = []
        for (boolean, value) in results:
            if isinstance(value, float):
                formatted_value = f'{value:.3e}'
            else:
                formatted_value = value
            formatted_results.append((boolean, formatted_value))
        return formatted_results

    def normalize(file):
        curve = file.copy()
        shift = 0
        if (curve[value].min() <= 0):
            shift = curve[value].min()
            curve[value] = ((curve[value] - shift) + 1)
        curve[f'{value} Error'] = (curve[f'{value} Error'] / curve[value].max())
        curve[value] = (curve[value] / curve[value].max())
        return curve

    def normalize2(file):
        curve = file.copy()
        shift = curve[value].median()
        curve[value] = (curve[value] - shift)
        curve[f'{value} Error'] = (curve[f'{value} Error'] / curve[value].max())
        curve[value] = (curve[value] / curve[value].max())
        curve[value] = ((curve[value] - curve[value].min()) + 1)
        return curve

    def normalize_sin(file):
        curve = file.copy()
        shift = curve[value].mean()
        curve[value] = (curve[value] - shift)
        curve[value] = (curve[value] / file[value].max())
        return curve

    def normalize_null(file):
        curve = file.copy()
        curve[value] = (curve[value] - curve[value].min())
        maxValue = curve[value].max()
        curve[value] = (curve[value] / maxValue)
        curve[f'{value} Error'] = (curve[f'{value} Error'] / maxValue)
        return curve

    def TimeDifference(name):
        curve = FileManager.load_data(name)
        return (curve.index[(- 1)] - curve.index[0])

    def delta(file):
        sum = 0
        length = len(file[value])
        for i in range(length):
            sum += (file[(value + ' Error')].iloc[i] ** 2)
        try:
            sum = np.sqrt((sum / length))
        except:
            sum = 0
        return sum

    def rolling_mid(file, rolling_time='28D'):
        file2 = file.copy()
        file2.sort_index(inplace=True)
        file2[value] = file2[value].rolling(window=rolling_time, center=True, min_periods=4).mean()
        return file2

    def fit_func_sin(x, a, b, c, d):
        return ((a * np.sin(((b * x) + c))) + d)

    def fit_func_sin2(x, a, b, c, d, e, f, g, h, i, j, k, l):
        return ((((((a * np.sin((((1 / b) * x) + c))) + d) + (e * np.sin((((1 / f) * x) + g)))) + h) + (i * np.sin((((1 / j) * x) + k)))) + l)

    def fit_func_peak(x, a, b, c, d):
        return ((a * np.exp((- (((x - b) / c) ** 2)))) + d)

    def Datetime_in_Unix(date):
        unix = []
        for i in date:
            unix.append(i.timestamp())
        return unix

    def Unix_in_Datetime(date):
        datetime = []
        for i in date:
            datetime.append(pd.to_datetime(i, unit='s'))
        return datetime
op86=>operation: class FindActive():

    @staticmethod
    def GetCategroies():
        files = pd.read_csv('sortedcurves.csv')
        matches = pd.DataFrame()
        noteskategorien = {1: 'inactive', 2: 'leichte var', 3: 'mittlere var', 4: 'Anstieg/Abfall', 5: 'starke var', 6: 'Periode >2J', 7: 'Periode 0.5-2J', 8: 'Spezialfälle', 9: 'SN'}
        noteskategorienCalc = {0: 'periodic', 1: 'linear', 2: 'supernova', 3: 'F_var_R', 4: 'periodicFast', 5: 'inactive'}
        df = pd.DataFrame(0, index=noteskategorienCalc.values(), columns=noteskategorien.values())
        df_names = pd.DataFrame(index=noteskategorienCalc.values(), columns=noteskategorien.values(), dtype=object)
        for col in df_names.columns:
            for row in df_names.index:
                df_names.at[(row, col)] = []
        check = 0
        check1 = 0
        galNotes = pd.read_csv('Lichtkurven/galaxienotes.csv')
        galCalc = pd.read_csv('sortedcurves.csv')
        for val in files['Unnamed: 0'].values:
            check1 += 1
            galCalc.columns = (['name'] + list(galCalc.columns[1:]))
            galCalc = galCalc.rename_axis('name', axis='index')
            galNotes['name'] = galNotes['name'].str.lower().str.replace(' ', '')
            galCalc['name'] = galCalc['name'].str.lower().str.replace(' ', '')
            nameCompare = val.lower().replace(' ', '')
            catNotes = galNotes.loc[((galNotes['name'] == nameCompare), 'category')].values
            catCalc = galCalc.loc[(galCalc['name'] == nameCompare)].values
            try:
                notesCat = noteskategorien[catNotes[0]]
            except:
                notesCat = 'inactive'
            calcTrue = []
            calcTrueNames = ''
            try:
                catCalc = catCalc[0]
            except:
                catCalc = ['name', '(False, 0.0)', False, False, '(False, 0)', False, False, 1]
            inactive = True
            for i in range((len(catCalc) - 2)):
                if (i == 0):
                    continue
                if ((isinstance(catCalc[i], str) and ('True' in catCalc[i])) or (isinstance(catCalc[i], bool) and (True == catCalc[i]))):
                    calcTrue.append(noteskategorienCalc[(i - 1)])
                    calcTrueNames = val
                    inactive = False
            if inactive:
                calcTrue.append('inactive')
                calcTrueNames = val
            for value in calcTrue:
                df.loc[(value, notesCat)] += 1
                df_names.loc[(value, notesCat)].append(calcTrueNames)
                check += 1
        print(df_names)
        print(df)
        total_sum = df.values.sum()
        print(f'Total sum:{total_sum} insgesamt:{check} - obere schleife: {check1}')
        return (df, df_names)

    @staticmethod
    def MatchCategory(notes, calc):
        if ((len(notes) == 0) or (len(calc) == 0)):
            print('ehm')
            return (f'match: False - Notes: Leer, Calc: Leer', False, False)
        calc = calc[0]
        noteskategorienCalc = {0: 'periodic', 1: 'linear', 2: 'supernova', 3: 'F_var_R', 4: 'periodicFast'}
        noteskategorien = {1: 'inactive', 2: 'leichte var', 3: 'mittlere var', 4: 'Anstieg/Abfall', 5: 'starke var', 6: 'Periode >2J', 7: 'Periode 0.5-2J', 8: 'Spezialfälle', 9: 'SN'}
        calcTrue = []
        for i in range((len(calc) - 2)):
            if (i == 0):
                continue
            if ((isinstance(calc[i], str) and ('True' in calc[i])) or (isinstance(calc[i], bool) and (True == calc[i]))):
                calcTrue.append(noteskategorienCalc[(i - 1)])
        print(f'notes: {notes}')
        print(notes[0])
        if (notes[0] == 0):
            notes[0] = 1
        notesTrue = noteskategorien[notes[0]]
        match = False
        if (notesTrue in calcTrue):
            match = True
        return (match, notesTrue, calcTrue)

    @staticmethod
    def compareCategories(name):
        galNotes = pd.read_csv('Lichtkurven/galaxienotes.csv')
        galCalc = pd.read_csv('sortedcurves.csv')
        galCalc.columns = (['name'] + list(galCalc.columns[1:]))
        galCalc = galCalc.rename_axis('name', axis='index')
        galNotes['name'] = galNotes['name'].str.lower().str.replace(' ', '')
        galCalc['name'] = galCalc['name'].str.lower().str.replace(' ', '')
        nameCompare = name.lower().replace(' ', '')
        catNotes = galNotes.loc[((galNotes['name'] == nameCompare), 'category')].values
        catCalc = galCalc.loc[(galCalc['name'] == nameCompare)].values
        (match, notesTrue, calcTrue) = FindActive.MatchCategory(catNotes, catCalc)
        compareString = f'''from Notes: {notesTrue}
Calculated: {', '.join(calcTrue)}'''
        return (compareString, match, notesTrue)

    def absoluteMag(name):
        name = name.replace(' ', '').lower()
        galaxy_active = pd.read_csv('pyasassn_tool/mainTargets.csv', delimiter='|')
        galaxy_active['namecheck'] = galaxy_active['name             '].str.lstrip().str.lower().str.replace(' ', '')
        try:
            mag = galaxy_active.loc[((galaxy_active['namecheck'] == name), 'abs_mag')].values[0]
            if (type(mag) == str):
                mag = float(mag.replace(' ', ''))
        except:
            mag = 0
        return mag

    def changingActivity(name, plot=False):
        curve = FileManager.load_data(name)
        curve = BasicCalcs.normalize_null(curve)
        cut = 100
        if plot:
            print('ZEUG: ', np.mean(curve[value][cut:]), np.mean(curve[value][:cut]), (np.mean(curve[value][cut:]) - np.mean(curve[value][:cut])))
            plt.scatter(curve.index, curve[value], color='blue')
            plt.scatter(curve.index[:cut], curve[value][:cut], color='red')
            plt.scatter(curve.index[(- cut):], curve[value][(- cut):], color='red')
            plt.tight_layout()
            plt.show()
        if (len(curve.index) > 150):
            if ((np.mean(curve[value][cut:]) - np.mean(curve[value][:cut])) == None):
                return 0.0
            return (np.mean(curve[value][cut:]) - np.mean(curve[value][:cut]))
        else:
            return 0.0

    def load_parameters(name='', variante=0):
        if (variante == 0):
            galaxy_active = pd.read_csv((path + 'new_active_galaxies.csv'), delimiter=',')
            try:
                cuts = galaxy_active.loc[((galaxy_active['name'] == name), 'cuts')].values[0]
            except:
                return None
            F = galaxy_active.loc[((galaxy_active['name'] == name), 'activity')].values[0]
            R = galaxy_active.loc[((galaxy_active['name'] == name), 'R')].values[0]
            amp_diff = galaxy_active.loc[((galaxy_active['name'] == name), 'amp_diff')].values[0]
            amplitude = galaxy_active.loc[((galaxy_active['name'] == name), 'amplitude')].values[0]
            T = galaxy_active.loc[((galaxy_active['name'] == name), 'period')].values[0]
            Dt = galaxy_active.loc[((galaxy_active['name'] == name), 'Dt')].values[0]
            std = galaxy_active.loc[((galaxy_active['name'] == name), 'std')].values[0]
            up = galaxy_active.loc[((galaxy_active['name'] == name), 'up')].values[0]
            down = galaxy_active.loc[((galaxy_active['name'] == name), 'down')].values[0]
            mean = galaxy_active.loc[((galaxy_active['name'] == name), 'mean')].values[0]
            peakA = galaxy_active.loc[((galaxy_active['name'] == name), 'peakA')].values[0]
            peakC = galaxy_active.loc[((galaxy_active['name'] == name), 'peakC')].values[0]
            lange = galaxy_active.loc[((galaxy_active['name'] == name), 'pointCount')].values[0]
            periodicpercent = galaxy_active.loc[((galaxy_active['name'] == name), 'periodicpercent')].values[0]
            StartEndDiff = galaxy_active.loc[((galaxy_active['name'] == name), 'StartEndDiff')].values[0]
            redshift = galaxy_active.loc[((galaxy_active['name'] == name), 'redshift')].values[0]
            periodicFast = galaxy_active.loc[((galaxy_active['name'] == name), 'periodicFast')].values[0]
            periodicFastFreq = galaxy_active.loc[((galaxy_active['name'] == name), 'periodicFastFreq')].values[0]
            magnitude = float(galaxy_active.loc[((galaxy_active['name'] == name), 'magnitude')].values[0])
            return {'R': R, 'F': F, 'amp_diff': amp_diff, 'T': T, 'Dt': Dt, 'std': std, 'up': up, 'down': down, 'mean': mean, 'peakA': peakA, 'peakC': peakC, 'lange': lange, 'periodicpercent': periodicpercent, 'StartEndDiff': StartEndDiff, 'redshift': redshift, 'periodicFast': periodicFast, 'magnitude': magnitude, 'periodicFastFreq': periodicFastFreq, 'amplitude': amplitude}
        elif (variante == 1):
            path1 = (path + 'new_active_galaxies.csv')
            name = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=0, dtype=str)
            F_var = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=1)
            R = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=2)
            F_and_R = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=3)
            cuts = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=4)
            amplitude = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=5)
            amp_diff = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=6)
            T = abs(np.loadtxt(path1, delimiter=',', skiprows=1, usecols=7))
            periodicpercent = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=8)
            Dt = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=9)
            std = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=10)
            up = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=11)
            down = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=12)
            mean = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=13)
            peakA = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=14)
            peakC = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=15)
            lange = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=16)
            StartEndDiff = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=17)
            redshift = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=18)
            periodicFast = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=19, dtype=str)
            periodicFastFreq = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=20, dtype=str)
            magnitude = np.loadtxt(path1, delimiter=',', skiprows=1, usecols=21, dtype=float)
            return (name, F_var, R, F_and_R, cuts, amplitude, amp_diff, T, periodicpercent, Dt, std, up, down, mean, peakA, peakC, lange, StartEndDiff, redshift, periodicFast, magnitude, periodicFastFreq)

    def FourierLombScargle(name, plot=False):
        curve = FileManager.load_data(name)
        file2 = BasicCalcs.normalize_null(curve)
        file2.dropna(inplace=True)
        file2[value] = (file2[value] - 0.5)
        numeric_index = BasicCalcs.Datetime_in_Unix(file2.index)
        if (len(numeric_index) < 20):
            return ([], [], 0, 0, 0)
        (frequency, power) = LombScargle(numeric_index, file2[value]).autopower(minimum_frequency=1e-09, maximum_frequency=1e-06, samples_per_peak=20)
        (peaks, properties) = signal.find_peaks(power, height=0.003)
        sorted_indices = np.argsort(properties['peak_heights'])[::(- 1)]
        sorted_peaks = peaks[sorted_indices]
        sorted_properties = properties['peak_heights'][sorted_indices]
        peaks = sorted_peaks[0:3]
        if plot:
            if True:
                teilen = (((60 * 60) * 24) * 365)
            else:
                teilen = 1
            if (max(power) >= 0.003):
                pass
            (x, y, Tsin) = FindActive.periodic(name, plot=True)
            console.print(f'Periods: {(1 / frequency[peaks])}, total - {(max(x) - min(x))}')
            x = (np.array(x) / teilen)
            x = (x - min(x))
            numeric_index = (np.array(numeric_index) / teilen)
            numeric_index = (numeric_index - min(numeric_index))
            (fig, (ax_t, ax_w)) = plt.subplots(2, 1, constrained_layout=True)
            plt.title(f'Galaxy: {name}')
            ax_t.plot(numeric_index, file2[value].values, 'b+')
            ax_t.plot(x, (y - 0.5), label='Sinus Fit', color='green')
            ax_t.set_xlabel(f'''Zeit in [Jahren]
Time [1/y] - Fit: {((Tsin / (2 * np.pi)) * teilen)} "Fourier: {(frequency[peaks] * teilen)} -> Fit T = {(1 / ((Tsin / (2 * np.pi)) * teilen))}''')
            ax_w.plot((frequency * teilen), power)
            ax_w.vlines(((Tsin / (2 * np.pi)) * teilen), min(power), max(power), color='red')
            ax_w.set_xlabel('Period duration [1/Jahre]')
            ax_w.set_ylabel('Normalized amplitude')
            ax_t.grid(True, which='both', linestyle='--', linewidth=0.5)
            ax_w.grid(True, which='both', linestyle='--', linewidth=0.5)
            plt.get_current_fig_manager().full_screen_toggle()
            plt.show()
        return (((2 * np.pi) * frequency[peaks]), power[peaks])

    def FourierFastPeriodic(name):

        def Datetime_in_Unix(date):
            unix = []
            for i in date:
                unix.append(i.timestamp())
            return unix

        def normalize(file):
            value = 'Flux'
            curve = file.copy()
            shift = 0
            if (curve[value].min() <= 0):
                shift = curve[value].min()
                curve[value] = ((curve[value] - shift) + 1)
            curve[f'{value} Error'] = (curve[f'{value} Error'] / curve[value].max())
            curve[value] = (curve[value] / curve[value].max())
            return curve
        file = pd.read_csv(f'final_light_curves/{name}.csv')
        file = normalize(file)
        t = Datetime_in_Unix(pd.to_datetime(file['JD']))
        mint = min(t)
        for i in range(len(t)):
            t[i] -= mint
        y = []
        for val in file['Flux'].values:
            y.append(val)
        min_freq = (1 / ((((2 * 365.25) * 24) * 60) * 60))
        max_freq = (1 / (((0.08 * 365.25) * 24) * 3600))
        (frequency, power) = LombScargle(t, y).autopower(minimum_frequency=min_freq, maximum_frequency=max_freq, samples_per_peak=40)
        max_power_idx = np.argmax(power)
        dominant_freq = frequency[max_power_idx]
        dominant_power = power[max_power_idx]
        return (dominant_power, dominant_freq)

    def peak_to_peak_amplitudes(name):
        curve = FileManager.load_data(name)
        file2 = curve.copy()
        if ((file2[value].max() / file2[value].min()) <= 0):
            console.log(f'''
ALARM {name}  -  {(file2[value].max() / file2[value].min())}
''')
        return (file2[value].max() / file2[value].min())

    def fractional_variation(name):
        curve = FileManager.load_data(name)
        try:
            if (curve == (- 1)):
                return (- 1)
        except:
            pass
        file2 = curve.copy()
        file2 = BasicCalcs.normalize(file2)
        activity = (((file2[value].std() ** 2) - (BasicCalcs.delta(file2) ** 2)) / file2[value].mean())
        return activity

    def peak(name):
        curve = FileManager.load_data(name)
        file2 = BasicCalcs.normalize_null(curve)
        file2.dropna(inplace=True)
        maximum = curve[value].max()
        numeric_index = BasicCalcs.Datetime_in_Unix(file2.index)
        if (len(numeric_index) < 2):
            return ([], [], 0, 0)
        time_diff = (numeric_index[(- 1)] - numeric_index[0])
        peak_index = file2[value].idxmax()
        peak_time = BasicCalcs.Datetime_in_Unix([peak_index])[0]
        amp = (curve[value].max() - curve[value].min())
        (params, params_covariance) = optimize.curve_fit(BasicCalcs.fit_func_peak, numeric_index, file2[value].values, p0=[1.2, peak_time, 10000000, 0.0], maxfev=100000, bounds=([(- 1), (0.8 * numeric_index[0]), 1000, 0], [4, (1.2 * numeric_index[(- 1)]), 10000000, 0.5]))
        x = np.linspace(min(numeric_index), max(numeric_index), 10000)
        y = BasicCalcs.fit_func_peak(x, *params)
        x = BasicCalcs.Unix_in_Datetime(x)
        if (len(params) < 4):
            print('eh')
            return (x, y, 0, 0)
        return (x, y, params[0], params[2])

    def periodic(name, plot=False):

        def Datetime_in_Unix(date):
            unix = []
            for i in date:
                unix.append(i.timestamp())
            return unix

        def normalize(file):
            value = 'Flux'
            curve = file.copy()
            shift = 0
            if (curve[value].min() <= 0):
                shift = curve[value].min()
                curve[value] = ((curve[value] - shift) + 1)
            curve[f'{value} Error'] = (curve[f'{value} Error'] / curve[value].max())
            curve[value] = (curve[value] / curve[value].max())
            return curve
        file = pd.read_csv(f'final_light_curves/{name}.csv')
        curve = file.copy()
        file = normalize(file)
        t = Datetime_in_Unix(pd.to_datetime(file['JD']))
        mint = min(t)
        for i in range(len(t)):
            t[i] -= mint
        y = []
        for val in file['Flux'].values:
            y.append(val)
        min_freq = (1 / (((20 * 365.25) * 24) * 3600))
        max_freq = (1 / (((2 * 365.25) * 24) * 3600))
        (frequency, power) = LombScargle(t, y).autopower(minimum_frequency=min_freq, maximum_frequency=max_freq, samples_per_peak=40)
        max_power_idx = np.argmax(power)
        dominant_freq = frequency[max_power_idx]
        dominant_power = power[max_power_idx]
        time_diff = (t[(- 1)] - t[0])
        amp = (curve[value].max() - curve[value].min())
        peak = 0
        amp_diff = 0
        x = [0, 0]
        y = [0, 0]
        try:
            (params, params_covariance) = optimize.curve_fit(BasicCalcs.fit_func_sin, t, file[value].values, p0=[amp, (1 / time_diff), 0, file[value].mean()], maxfev=100000)
            x = np.linspace(min(t), max(t), 10000)
            y = BasicCalcs.fit_func_sin(x, *params)
            Tsin = abs(params[1])
            if plot:
                return (x, y, Tsin)
            x = BasicCalcs.Unix_in_Datetime(x)
            (T, peaks) = FindActive.FourierLombScargle(name)
            for i in range(len(T)):
                if (((T[i] / Tsin) < 1.2) and ((T[i] / Tsin) > 0.8)):
                    peak = peaks[i]
                    amp_diff = (y.max() - y.min())
        except:
            print('kein sin')
            if plot:
                return ([0, 0], [0, 0], 0)
        return (x, y, dominant_power, amp_diff, dominant_freq, peak)

    def periodic3(name):
        curve = FileManager.load_data(name)
        file2 = BasicCalcs.rolling_mid(curve)
        file2 = BasicCalcs.normalize_null(curve)
        file2.dropna(inplace=True)
        maximum = curve[value].max()
        numeric_index = BasicCalcs.Datetime_in_Unix(file2.index)
        if (len(numeric_index) < 20):
            return ([], [], 0, 0, 0, 0)
        time_diff = (numeric_index[(- 1)] - numeric_index[0])
        amp = (curve[value].max() - curve[value].min())
        try:
            (params, params_covariance) = optimize.curve_fit(BasicCalcs.fit_func_sin, numeric_index, file2[value].values, p0=[amp, (1 / time_diff), 0, file2[value].mean()], maxfev=100000)
        except:
            return ([], [], 0, 0, 0, 0)
        x = np.linspace(min(numeric_index), max(numeric_index), 10000)
        y = BasicCalcs.fit_func_sin(x, *params)
        Tsin = abs(params[1])
        if plot:
            return (x, y, Tsin)
        x = BasicCalcs.Unix_in_Datetime(x)
        (T, peaks) = FindActive.FourierLombScargle(name)
        for i in range(len(T)):
            if (((T[i] / Tsin) < 1.2) and ((T[i] / Tsin) > 0.8)):
                return (x, y, abs(params[0]), (y.max() - y.min()), (1 / abs((params[1] * 60))), peaks[i])
            else:
                pass
        return (x, y, abs(params[0]), (y.max() - y.min()), (1 / abs((params[1] * 60))), 0)

    def StdPeak(name):
        curve = FileManager.load_data(name)
        lange = len(curve)
        curve = BasicCalcs.normalize_null(curve)
        mean = curve[value].mean()
        std = curve[value].std()
        rolling = curve[value].rolling(window='30D', center=False, min_periods=8)
        rolling_std = rolling.std().values
        rolling_mid = rolling.mean().values
        up = 0
        down = 0
        for i in range(len(rolling_std)):
            if ((rolling_mid[i] + rolling_std[i]) > (mean + std)):
                up += 1
            elif ((rolling_mid[i] - rolling_std[i]) < (mean - std)):
                down += 1
        return (std, up, down, mean, lange)

    def jumps(name):
        curve = FileManager.load_data(name)
        file2 = BasicCalcs.normalize(curve)

    def stetig(name):
        curve = FileManager.load_data(name)
        file2 = BasicCalcs.normalize(curve)
st89=>start: start start
io91=>inputoutput: input: 
cond95=>operation: with open((path + 'new_active_galaxies.csv'), 'w') as datei:
    datei.write('name,activity,R,activity*R,cuts,amplitude,amp_diff,period,periodicpercent,Dt,std,up,down,mean,peakA,peakC,pointCount,StartEndDiff,redshift,periodicFast,periodicFastFreq,magnitude\n') if  ((not config['ReCalculateOnlyNew']) or (not os.path.exists((path + 'new_active_galaxies.csv'))))
op105=>operation: galaxy_active = pd.read_csv((path + 'new_active_galaxies.csv'))
op107=>operation: files = [f for f in listdir(load_path) if isfile(join(load_path, f))]
op109=>operation: show_galaxies_lower = [item.replace(' ', '').lower() for item in show_galaxies]
cond112=>condition: if config['ReCalculateOnlyNew']
op116=>operation: savedCurves = [f[:(- 4)] for f in files]
cond119=>condition: for i in reversed(range(len(savedCurves)))
cond137=>condition: if (savedCurves[i] in galaxy_active['name'].values)
sub141=>subroutine: savedCurves.pop(i)
sub143=>subroutine: files.pop(i)
cond154=>operation: FileManager.group_galaxies(file[:(- 4)]) while  file in tqdm(files)
e166=>end: end start
cond170=>operation: start() if  (config['ReCalculate'] or config['ReCalculateOnlyNew'])
cond181=>operation: Plots.show_plots() if  config['Plots']['ShowAllPlots']
cond192=>condition: if config['Plots']['ShowGroupPlot']
op196=>operation: correlation = pd.DataFrame(columns=['xName', 'yName', 'correlation', 'removed', 'len', 'delete'])
cond199=>condition: if (config['Plots']['ShowGroupPlotAll'] == False)
sub203=>subroutine: Plots.standart1()
cond348=>condition: if config['Plots']['ShowFourierPlot']
sub352=>subroutine: console.print(groups)
cond355=>condition: if (show_galaxies != [])
cond360=>condition: for name in show_galaxies
op378=>operation: params = FindActive.load_parameters(name)
cond381=>operation: FindActive.FourierLombScargle(name, plot=True) if  (CONDITION(**params, classify=True) or config['Plots']['IgnoreConditions'])
cond436=>condition: if (config['Plots']['ShowClassifyPlot'] or config['Plots']['sortedPlot'] or config['Plots']['statisticalDistribution'])
op440=>operation: liste = listdir('final_light_curves')
op442=>operation: galaxy_active = pd.read_csv((path + 'new_active_galaxies.csv'))
op444=>operation: groups = pd.DataFrame()
cond447=>condition: for file in liste
op469=>operation: name = file[:(- 4)]
cond472=>operation: continue if  ((name not in show_galaxies) and (show_galaxies != []))
op482=>operation: params = FindActive.load_parameters(name)
op484=>operation: try:
    add = pd.DataFrame([list(CONDITION(**params, classify=True))], index=[name], columns=['periodic', 'linear', 'supernova', 'F_var_R', 'periodicFast', 'minPoint'])
    groups = pd.concat([groups, add])
except:
    continue
st489=>start: start count_true
io491=>inputoutput: input: row
io497=>inputoutput: output:  sum((1 for value in row if ((value is True) or (isinstance(value, tuple) and (value[0] == True)))))
e495=>end: end function return
cond548=>condition: if config['Plots']['changeActivity']
cond553=>condition: if (show_galaxies != [])
cond558=>condition: for name in show_galaxies
op576=>operation: params = FindActive.load_parameters(name)
cond579=>operation: FindActive.changingActivity(name, plot=True) if  (CONDITION(**params, classify=True) or config['Plots']['changeActivity'])
cond634=>condition: if config['Plots']['showMatchesOld']
op638=>operation: files = pd.read_csv('sortedcurves.csv')
op640=>operation: matches = []
cond643=>condition: for val in files['Unnamed: 0'].values
op652=>operation: (_, match, category) = FindActive.compareCategories(val)
sub654=>subroutine: matches.append({'name': val, 'match': match, 'category': category})
op658=>operation: matches_df = pd.DataFrame(matches)
sub660=>subroutine: Plots.matchesPlot(matches_df)
cond666=>condition: if config['Plots']['showMatches']['show']
op670=>operation: (df, df_names) = FindActive.GetCategroies()
op672=>operation: column_sums = df.sum()
op674=>operation: normalized_df = (df / column_sums)
cond677=>operation: Plots.plotMateches(normalized_df, df_names) if  config['Plots']['showMatches']['showPlot']
op687=>operation: SN = df_names['SN']['inactive']
op689=>operation: plot = SN
op694=>operation: '\n    TODO: group plot correlation für alle kombinationen durchrechnen lassen und dann ausgeben\n    TODO: SDSSJ15242 sollte langzeit periodisch sein\n    TODO: langsame periode soll abgeschnitten werden und dann in fast übergehen\n    \n    TODO: fehlen von kategorien anzeigen yes\n    TODO: abs magnitude runterladen\n'
op593=>operation: liste = listdir('final_light_curves')
cond596=>condition: for i in liste
op614=>operation: params = FindActive.load_parameters(i[:(- 4)])
cond617=>operation: FindActive.changingActivity(i[:(- 4)], plot=True) if  (CONDITION(**params, classify=True) or config['Plots']['changeActivity'])
op395=>operation: liste = listdir('final_light_curves')
cond398=>condition: for i in liste
op416=>operation: params = FindActive.load_parameters(i[:(- 4)])
cond419=>operation: FindActive.FourierLombScargle(i[:(- 4)], plot=True) if  (CONDITION(**params, classify=True) or config['Plots']['IgnoreConditions'])
op207=>operation: parameters = ['F_var', 'R', 'F_and_R', 'cuts', 'amplitude', 'amp_diff', 'T', 'periodicpercent', 'Dt', 'std', 'up', 'down', 'mean', 'peakA', 'peakC', 'lange', 'StartEndDiff', 'redshift', 'periodicFast', 'magnitude']
cond210=>condition: for x in range(len(parameters))
cond250=>condition: for y in range((x + 1), len(parameters))
op265=>operation: (corr, deleted, lange) = Plots.standart1(x=parameters[x], y=parameters[y], plot=False)
op267=>operation: new_row = pd.DataFrame([{'xName': parameters[x], 'yName': parameters[y], 'correlation': abs(corr), 'removed': deleted, 'len': lange, 'delete': False}])
op269=>operation: correlation = pd.concat([correlation, new_row], ignore_index=True)
op271=>operation: new_row = pd.DataFrame([{'xName': parameters[y], 'yName': parameters[x], 'correlation': abs(corr), 'removed': deleted, 'len': lange, 'delete': True}])
op273=>operation: correlation = pd.concat([correlation, new_row], ignore_index=True)
op277=>operation: (corr, deleted, lange) = Plots.standart1(x=parameters[x], y=parameters[x], plot=False)
op279=>operation: new_row = pd.DataFrame([{'xName': parameters[x], 'yName': parameters[x], 'correlation': abs(corr), 'removed': deleted, 'len': lange, 'delete': True}])
op281=>operation: correlation = pd.concat([correlation, new_row], ignore_index=True)
sub285=>subroutine: correlation.sort_values(by=['correlation'], ascending=False, inplace=True)
sub287=>subroutine: correlation.reset_index(drop=True, inplace=True)
op289=>operation: correlation = correlation[(correlation['removed'] < 500)]
op291=>operation: heatmap_data = correlation.pivot(index='xName', columns='yName', values='correlation')
sub293=>subroutine: plt.figure(figsize=(10, 8))
sub295=>subroutine: sns.heatmap(heatmap_data, annot=True, cmap='Blues', linewidths=0.5, linecolor='black', cbar_kws={'label': 'Correlation'})
sub297=>subroutine: plt.title('Heatmap of Values', fontsize=18)
sub299=>subroutine: plt.xlabel('X Name', fontsize=14)
sub301=>subroutine: plt.ylabel('Y Name', fontsize=14)
sub303=>subroutine: plt.xticks(rotation=45, ha='right', fontsize=12)
sub305=>subroutine: plt.yticks(rotation=0, fontsize=12)
sub307=>subroutine: plt.show()
sub309=>subroutine: plt.close()
op311=>operation: correlation = correlation[(correlation['delete'] == False)]
cond314=>condition: for i in range(40)
cond331=>operation: Plots.standart1(correlation.iloc[i]['xName'], correlation.iloc[i]['yName'], plot=True) if  (correlation.iloc[i]['yName'] == 'magnitude')

op2->op4
op4->op6
op6->op8
op8->op10
op10->op12
op12->op14
op14->op16
op16->op18
op18->op20
op20->op22
op22->op24
op24->op26
op26->op28
op28->op30
op30->op32
op32->op34
op34->op36
op36->op38
op38->op40
op40->op42
op42->op44
op44->sub46
sub46->op48
op48->op50
op50->op52
op52->op54
op54->op56
op56->op58
op58->op60
op60->op62
op62->op64
op64->op66
op66->op68
op68->op70
op70->op72
op72->op74
op74->op76
op76->op78
op78->op80
op80->op82
op82->op84
op84->op86
op86->st89
st89->io91
io91->cond95
cond95->op105
op105->op107
op107->op109
op109->cond112
cond112(yes)->op116
op116->cond119
cond119(yes)->cond137
cond137(yes)->sub141
sub141->sub143
sub143->cond119
cond137(no)->cond119
cond119(no)->cond154
cond154->e166
e166->cond170
cond170->cond181
cond181->cond192
cond192(yes)->op196
op196->cond199
cond199(yes)->sub203
sub203->cond348
cond348(yes)->sub352
sub352->cond355
cond355(yes)->cond360
cond360(yes)->op378
op378->cond381
cond381->cond360
cond360(no)->cond436
cond436(yes)->op440
op440->op442
op442->op444
op444->cond447
cond447(yes)->op469
op469->cond472
cond472->op482
op482->op484
op484(left)->cond447
cond447(no)->st489
st489->io491
io491->io497
io497->e495
cond436(no)->cond548
cond548(yes)->cond553
cond553(yes)->cond558
cond558(yes)->op576
op576->cond579
cond579->cond558
cond558(no)->cond634
cond634(yes)->op638
op638->op640
op640->cond643
cond643(yes)->op652
op652->sub654
sub654(left)->cond643
cond643(no)->op658
op658->sub660
sub660->cond666
cond666(yes)->op670
op670->op672
op672->op674
op674->cond677
cond677->op687
op687->op689
op689->op694
cond666(no)->op694
cond634(no)->cond666
cond553(no)->op593
op593->cond596
cond596(yes)->op614
op614->cond617
cond617->cond596
cond596(no)->cond634
cond548(no)->cond634
cond355(no)->op395
op395->cond398
cond398(yes)->op416
op416->cond419
cond419->cond398
cond398(no)->cond436
cond348(no)->cond436
cond199(no)->op207
op207->cond210
cond210(yes)->cond250
cond250(yes)->op265
op265->op267
op267->op269
op269->op271
op271->op273
op273(left)->cond250
cond250(no)->op277
op277->op279
op279->op281
op281(left)->cond210
cond210(no)->sub285
sub285->sub287
sub287->op289
op289->op291
op291->sub293
sub293->sub295
sub295->sub297
sub297->sub299
sub299->sub301
sub301->sub303
sub303->sub305
sub305->sub307
sub307->sub309
sub309->op311
op311->cond314
cond314(yes)->cond331
cond331->cond314
cond314(no)->cond348
cond192(no)->cond348
cond112(no)->cond154
</textarea></div>
        <div><button id="run" type="button">Run</button> <button onclick="HelpText()">Format Help</button></div>
        <div id="HelpTextBlock" style="display:none"><br/>Conditions can also be redirected like cond(yes, bottom) or cond(yes, right)
... and the other symbols too... like sub1(right)<br/>
You can also tweak the <b>diagram.drawSVG('diagram', {});</b> script in this file for more changes<br/>
This is based on <a href="https://github.com/adrai/flowchart.js">flowchart.js on github</a> and <a href="http://flowchart.js.org">http://flowchart.js.org</a> more documentation can be found over there.
</div><br/><div id="svgbase64"></div>
        <div id="pngbase64"></div>

        <div id="canvas"></div>
    </body>
</html>